<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>OAuth Popup Simulation - Authorization</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 24px; line-height: 1.5; }
        input, button { padding: 10px 12px; font-size: 15px; }
        form { display: grid; gap: 12px; max-width: 360px; }
        .row { display: grid; gap: 6px; }
        .actions { display: flex; gap: 8px; }
        .log { white-space: pre-wrap; padding: 12px; background: #fafafa; border: 1px solid #eee; border-radius: 8px; min-height: 40px; }
    </style>
</head>
<body>
    <h2>Authorization Popup (auth.html)</h2>
    <p>Fill the credentials and authorize to continue.</p>

    <form id="auth-form">
        <div class="row">
            <label for="username">Username</label>
            <input id="username" name="username" type="text" placeholder="username" value="user.demo" required>
        </div>
        <div class="row">
            <label for="password">Password</label>
            <input id="password" name="password" type="password" placeholder="••••••" value="secret" required>
        </div>
        <div class="actions">
            <button id="btn-login" type="submit">Login</button>
            <button id="btn-deny" type="button">Deny</button>
            <button id="btn-close" type="button">Close</button>
        </div>
    </form>

    <div class="log" id="log"></div>

    <script src="oauth-sim.js"></script>
    <script>
        (function () {
            const logEl = document.getElementById('log');
            function log(msg, data) {
                const time = new Date().toISOString();
                logEl.textContent += `[${time}] ${msg}` + (data ? `\n${JSON.stringify(data, null, 2)}` : '') + "\n\n";
            }

            const params = new URLSearchParams(location.search);
            const authorizeParams = {
                client_id: params.get('client_id'),
                response_type: params.get('response_type'),
                expiration: params.get('expiration'),
                redirect_uri: params.get('redirect_uri'),
                state: params.get('state'),
                locale: params.get('locale'),
                style: params.get('style'),
                socialLoginProviderName: params.get('socialLoginProviderName'),
                autoAccountCreateForSocial: params.get('autoAccountCreateForSocial') === 'true',
                code_challenge: params.get('code_challenge'),
                code_challenge_method: params.get('code_challenge_method'),
                // para fluxo implicit
                implicit: params.get('implicit') === 'true'
            };

            log('Parameters received in auth.html:', authorizeParams);

            document.getElementById('auth-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const username = (document.getElementById('username')).value.trim();
                const password = (document.getElementById('password')).value.trim();
                if (!username || !password) {
                    log('Invalid credentials');
                    return;
                }
                // Simulate positive authorization
                if (authorizeParams.implicit) {
                    // implicit: redirect to callback with token in hash
                    const token = generateFakeToken();
                    const expiresIn = '3600';
                    const ssl = 'true';
                    const redirect = new URL(authorizeParams.redirect_uri);
                    const state = encodeURIComponent(authorizeParams.state || '');
                    const hash = `#access_token=${encodeURIComponent(token)}&expires_in=${expiresIn}&ssl=${ssl}&username=${encodeURIComponent(username)}&state=${state}`;
                    redirect.hash = hash;
                    location.assign(redirect.toString());
                    return;
                }
                // pkce: code in query to exchange for token in the callback
                const code = generateRandomString(window).slice(0, 12);
                const original = new URL(authorizeParams.redirect_uri);
                const qp = new URLSearchParams(original.search);
                qp.set('code', code);
                qp.set('state', authorizeParams.state || '');
                original.search = '?' + qp.toString();
                location.assign(original.toString());
            });

            document.getElementById('btn-deny').addEventListener('click', () => {
                const redirect = new URL(authorizeParams.redirect_uri);
                if (authorizeParams.implicit) {
                    // For implicit, error is returned via hash along with state
                    const state = encodeURIComponent(authorizeParams.state || '');
                    const hash = `#error=access_denied&error_description=${encodeURIComponent('User denied access')}&state=${state}`;
                    redirect.hash = hash;
                    location.assign(redirect.toString());
                    return;
                }
                // For PKCE/code flow, error is returned via query along with state
                const qp = new URLSearchParams(redirect.search);
                qp.set('error', 'access_denied');
                qp.set('error_description', 'User denied access');
                qp.set('state', authorizeParams.state || '');
                redirect.search = '?' + qp.toString();
                location.assign(redirect.toString());
            });

            document.getElementById('btn-close').addEventListener('click', () => {
                window.close();
            });
        })();
    </script>
</body>
</html>

