<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>OAuth Popup Simulation - Callback</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 24px; line-height: 1.5; }
        .log { white-space: pre-wrap; padding: 12px; background: #fafafa; border: 1px solid #eee; border-radius: 8px; min-height: 60px; }
        .small { color: #666; font-size: 13px; }
    </style>
</head>
<body>
    <h2>Callback (callback.html)</h2>
    <p class="small">This page completes the flow: it sends an event to the main window and closes the popup.</p>
    <div id="log" class="log"></div>

    <script src="oauth-sim.js"></script>
    <script>
        (function () {
            const logEl = document.getElementById('log');
            function log(msg, data) {
                const time = new Date().toISOString();
                logEl.textContent += `[${time}] ${msg}` + (data ? `\n${JSON.stringify(data, null, 2)}` : '') + "\n\n";
            }

            // This function replicates the semantics of a simplified completeOAuth2.
            function completeOAuth2Like() {
                try {
                    const search = location.search.replace(/^\?/, '');
                    const hash = location.hash.replace(/^#/, '');
                    const searchParams = decodeQueryString(search);
                    const hashParams = decodeQueryString(hash);

                    const isPkce = !!searchParams.code;
                    // State may come via query (PKCE) or hash (implicit), including for error responses
                    const stateRaw = isPkce ? (searchParams.state || hashParams.state) : (hashParams.state || searchParams.state);
                    const state = stateRaw ? JSON.parse(decodeURIComponent(stateRaw)) : undefined;

                    const clientId = 'demo-client-id';
                    const stateStorageKey = `ARCGIS_REST_JS_AUTH_STATE_${clientId}`;

                    if (!state) {
                        log('Error: missing state.');
                        notifyAndClose({ error: 'oauth-error', errorMessage: 'Missing state' }, clientId);
                        return;
                    }

                    const savedStateId = localStorage.getItem(stateStorageKey);
                    if (!savedStateId) {
                        log('Error: saved state not found.');
                        notifyAndClose({ error: 'no-auth-state', errorMessage: 'No auth state' }, clientId);
                        return;
                    }
                    const parsed = typeof state === 'string' ? JSON.parse(state) : state;
                    if (parsed.id !== savedStateId) {
                        log('Error: mismatched state.');
                        notifyAndClose({ error: 'mismatched-auth-state', errorMessage: 'Mismatched state' }, clientId);
                        return;
                    }

                    // Errors may be returned via query (PKCE) or hash (implicit)
                    const errorFromQuery = searchParams.error;
                    const errorFromHash = hashParams.error;
                    if (errorFromQuery || errorFromHash) {
                        const error = errorFromQuery || errorFromHash;
                        const errorMessage = (errorFromQuery ? searchParams.error_description : hashParams.error_description) || 'Unknown error';
                        log('Error returned by the authorization server', { error, errorMessage });
                        notifyAndClose({ error, errorMessage }, clientId);
                        return;
                    }

                    if (isPkce && searchParams.code) {
                        // Simulate exchanging code for token
                        const token = generateFakeToken();
                        const expires = new Date(Date.now() + 3600 * 1000);
                        const result = {
                            ssl: true,
                            token,
                            expires,
                            username: 'user.demo',
                            refreshToken: 'refresh-' + generateRandomString(window).slice(0, 8),
                            refreshTokenExpires: new Date(Date.now() + 7 * 24 * 3600 * 1000)
                        };
                        log('PKCE completed. Sending event to the main window and closing.');
                        localStorage.removeItem(stateStorageKey);
                        notifyAndClose(result, clientId);
                        return;
                    }

                    if (!isPkce && hashParams.access_token) {
                        const result = {
                            ssl: hashParams.ssl === 'true',
                            token: hashParams.access_token,
                            expires: new Date(Date.now() + parseInt(hashParams.expires_in || '3600', 10) * 1000),
                            username: hashParams.username
                        };
                        log('Implicit completed. Sending event and closing.');
                        localStorage.removeItem(stateStorageKey);
                        notifyAndClose(result, clientId);
                        return;
                    }

                    log('Unknown error in callback');
                    notifyAndClose({ error: 'oauth-error', errorMessage: 'Unknown error' }, clientId);
                } catch (e) {
                    log('Exception in callback', { message: e.message, stack: e.stack });
                    notifyAndClose({ error: 'oauth-error', errorMessage: e.message }, 'demo-client-id');
                }
            }

            // Small delay to ensure window/opener state settles before completing OAuth
            setTimeout(() => {
                completeOAuth2Like();
            }, 100);
        })();
    </script>
</body>
</html>

